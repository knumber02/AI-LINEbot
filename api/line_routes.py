from fastapi import APIRouter, Request, HTTPException
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import MessageEvent, TextMessage, TextSendMessage
import json
from .state import User, users
from openai.error import OpenAIError
import openai


line_router = APIRouter()

with open('/src/config.json') as f:
    config = json.load(f)

# JSONからAPIキーを取得
openai.api_key = config['OPENAI_API_KEY']
line_bot_api = LineBotApi(config['LINE_CHANNEL_ACCESS_TOKEN'])
handler = WebhookHandler(config['LINE_CHANNEL_SECRET'])

@line_router.post("/webhook")
async def webhook(request: Request):
    signature = request.headers['X-Line-Signature']
    body = await request.body()

    try:
        handler.handle(body.decode(), signature)
    except InvalidSignatureError:
        raise HTTPException(status_code=400, detail="Invalid signature. Please check your channel access token/channel secret.")

    return 'OK'

@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    print("Message received")
    user_id = event.source.user_id
    text = event.message.text

    if user_id not in users:
        users[user_id] = User(id=user_id, name=user_id, personality="You are a friendly, caring, and cheerful real girlfriend.", messages=[])

    user = users[user_id]

    if text == "性格チェンジ！":
        user.personality = "You are a friendly, caring, and cheerful real girlfriend."
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(text="Personality updated!")
        )
        return

    user.messages.append({"role": "user", "content": text})
    chat_model = "gpt-3.5-turbo"

    print(f'Received message from user {user_id}: {text}') # Log message received from user

    # Limit the conversation history to the latest 10 messages to avoid reaching the token limit.
    conversation_history = user.messages[-10:]

    conversation_history.insert(0, {"role": "system", "content": user.personality})

    try:
        response = openai.ChatCompletion.create(
            model=chat_model,
            messages=conversation_history
        )
        response_content = response['choices'][0]['message']['content']
        print(f'Response generated by AI: {response_content}')  # Log response generated by AI

        # Filter out inappropriate content
        inappropriate_words = ['inappropriate', 'offensive']
        if any(word in response_content for word in inappropriate_words):
            response_content = "I'm sorry, but I can't assist with that."

        # Post-processing: Add more "girlfriend-like" phrases.
        response_content = f"あなたの彼女からのメッセージ: {response_content} ❤️"

    except OpenAIError as e:
        # Custom error message
        response_content = f"ごめんなさい、今ちょっと眠いの... もう少し待っててね。"
        print(f'Error occurred: {str(e)}')  # Log error if any occurs

    user.messages.append({"role": "assistant", "content": response_content})

    line_bot_api.reply_message(
        event.reply_token,
        TextSendMessage(text=response_content)
    )
